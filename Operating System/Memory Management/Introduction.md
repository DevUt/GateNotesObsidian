How do we load data?

Each byte has a address. The Memory Management Unit (MMU) is responsible for loading for the memory. 

# Basic Hardware
Main memory and registers are both easily accessible to the CPU, i.e there are instructions which help us  to access them.  

```asm
MOV A, B
MOV A, [2056H] 
```

But that is not the case with disk addresses.

Registers are built into the CPU. These are generally accessible in one clock cycle.

But the same cannot be said about Main memory. Main memory is accessed using the memory bus.

We send address on the address bus to MMU.
MMU sends us data on the data bus.
This process takes up many clock cycles. During this period the CPU is idle. This is intolerable due the frequency of data we access. To solve this we introduce a new memory which addresses this speed differential, i.e the *cache*.

![[Introduction 2023-05-06 13.50.33.excalidraw]]

## Hardware protection
We should also ensure that the correct process is accessing the memory.

Imagine

![[Introduction 2023-05-06 12.56.08.excalidraw]]

Here B's request to access the memory of A, should be denied.

### Naive Method: Base Limit registers
We can use two registers base and limit to achieve protection.
The base register indicates smallest legal physical memory address for the process.
![[Introduction 2023-05-06 13.21.22.excalidraw]]

The limit register indicates the size of the process memory.

![[Introduction 2023-05-06 13.01.44.excalidraw]]

>[!Question]
>How do we handle multiple programs(preemptive kernel) using this approach?
>>The dispatcher would handle this, loading and storing base and limit registers are a privileged operation.

## Address Binding

![[Introduction 2023-05-06 13.14.12.excalidraw]]

Here we are binding it the actual memory location.

Depending on the memory execution techniques we see that a program may also move between main memory and swap memory during execution.
Its not a guarantee that the process would be granted the same location in memory as it had before it was swapped. 

Most of the OS allow the process to be in any part of memory.

Programs generate a symbolic address, and then compiler maps them to a relocatable address. 

```c++
int x;
x = 10;
```

`x` here is the symbolic address, i.e it is a symbol that is pointing to a memory location.

Now the compiler bind the symbolic address to a relocatable address.
![[Introduction 2023-05-06 13.32.10.excalidraw]]

Loader would bind the relocatable address to an actual physical address.

![[Introduction 2023-05-06 13.36.16.excalidraw]]

### 3 places to bind to physical memory address

#### Compile time
If we know where the process would reside in memory, then *absolute code* can be generated. 

>[!example]
>`[105] = 10`

If some time later, the starting address changes the program has to be recompiled.
The MS-DOS COM format programs are bound at compile time.

#### Load Time
If it is not known at compile time, then the compiler generates a relocatable code. In this case binding is delayed till load time. If starting address changes the we only need to reload the relocatable code.

#### Execution Time
If the process can be moved from one memory segment to another memory segment, then binding must be delayed till run time. Special hardware is needed. Most of the current general purpose systems use this method.


# Logical vs Physical Address

The address generated by the CPU is referred to as *Logical address*

The physical address is the actual address in the memory.

>[!Note]
>Compile time and load time address binding methods generate identical logical and physical address.

Runtime mapping from logical to physical address is provided by MMU.

## Relocation addressing
Is same as [[#Naive Method: Base Limit registers|Base limit register]] scheme.

Whenever we want to change the location of the process, we can simply change the relocation register.
![[Introduction 2023-05-06 14.22.11.excalidraw]]

## Dynamic Loading
In our discussions, so far we have seen that we load the entire program and its data into the  main memory. The size of the process gets limited by the size of the main memory. 

All our routines are kept on the disk in a relocatable format. When a routine needs to call another routine it checks whether it has been correctly loaded into the memory. If not then we load it.

>[!Example]
>Lets say we have an `error()` function. This function is rarely called. Keeping it in memory is  unnecessary. When we need it we then only load it.

This is done by the programmer. OS helps by providing functions to support loading. 
>[!Info]
>Linux provides it using [dlopen](https://man7.org/linux/man-pages/man3/dlopen.3.html)

## Dynamic Linking

There are two types of linking
1. Static linking
2. Dynamic linking

```c
printf("Hello, world!");
```
 
 The `printf` exists in the `stdio.h` library. The function should now exist in our program's binary image. And all its supporting functions also. 

Packing of `printf` in the binary image itself is static linking.

In dynamic linking we replace the function call using a stub.

This stub is a reference to the function. It is a piece of code, which details how to find the routine. It replaces itself with the address of the routine to be called. Thus the next time it is reached, it can directly call the library routine. 

>[!Example]
>So system libraries are a great example. Because if every program carried a version of `printf` with itself then the programs would be huge. Also this helps in library updates.

Dynamic linking requires help of OS unlike Dynamic loading.