Paging is a memory management scheme that allows the process memory to be non contiguous. 

# Basic Method

![[Paging 2023-05-07 02.42.38.excalidraw]]

Physical memory is broken into fixed sized blocks known as frames.
Logical memory is broken into fixed sized blocks known as pages.
Pages are loaded into frames.

>[!Question]
>How does the address generated by a CPU usually look?
>> [!Answer]-
>> 000000111111, we can represent it in hex also.

![[Pasted image 20230507025314.png]]
The logical address is divided into two parts
1. Page number (p)
2. Page offset (d)

Lets imagine 4 bits
2 bits for page number and 2 bits for page offset.

Lets take about frames.
0000 -> 0th byte -> first frame
	0010 -> 2nd byte -> first frame
0100 -> 8th byte -> second frame
1000 -> 16th byte -> third frame

![[Paging 2023-05-07 03.02.36.excalidraw]]

In decimal
0000 -> 0th -> first 
0100 -> 100th  -> second 
0200 -> 200th -> third 
0300 -> 300th -> fourth
1300 -> 1300th  -> fourteenth 

The page size (like the frame size) is defined by the hardware. This is typically a power of two. It makes the translation easy.

If the logical address space is $2^m$ , page size is $2^n$ 

Page number = $\frac{\text{address}}{\text{page size}}$ 
(address >> $n$) divides by $2^n$ 

Page offset = $\text{address} \mathbin{\%} \text{page size}$
(address&(page_size - 1)) 
![[Paging 2023-05-07 03.45.13.excalidraw]]


![[Paging 2023-05-07 03.17.18.excalidraw]]

>[!question]
>What if the logical address space and the page size were of power of 3? Lets say address is x. What is the page number and the page offset?
>>[!answer]-
>>Divide by page size for page number. The reason it is not used because it is inefficient to perform with respect to binary which just requires truncation digits.

